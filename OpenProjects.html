<!--#include virtual="header.incl" -->

<div class="www_sectiontitle">Open LLVM Projects</div>

<ul>
  <li><a href="#gsoc17">Google Summer of Code 2017</a>
	  
    <ul><a href="http://clang.llvm.org/">LLVM Core</a>
	  <li><a href="#bitcode_fuzzing">Fuzzing the Bitcode reader</a></li>
	  <li><a href="#debuginfo_overhead">Improve optimizer overhead with debug info</a></li>
	  <li><a href="#thinlto_global">ThinLTO: propagating more global informations</a></li>
	  <li><a href="#debuginfo_codegen_mismatch">Adding Debug Info shouldn't change the generated code</a></li>
	  <li><a href="#hashmap_codegen_mismatch">Changing hashmap iteration order should not change the generated code</a></li>
	  <li><a href="#opt_remarks">We need better optimization remarks!</a></li>
	  <li><a href="#llvmir_dump">Smarter way of dumping LLVM IR with -emit-after-all</a></li>
	  <li><a href="#codegen_testing">Improve code generation testing</a></li>
    </ul>
    <ul><a href="http://clang.llvm.org/">Clang</a>
      <li><a href="#clang-template-instantiation-sugar">Extend clang AST to
          provide information for the type as written in template
          instantiations</a>
      </li>
      <li><a href="#clang-shell-autocompletion-support">Shell auto-completion
          support for clang</a>
      </li>
      <li><a href="#clang-diff-tool">Clang-based C/C++ diff tool</a></li>
    </ul>
    <ul><a href="http://clang.llvm.org/extra/clang-tidy/">Clang-tidy</a>
      <li><a href="#clang-tidy-pointer-deref">Find dereference of pointers</a>
      </li>
    </ul>
    <ul><a href="http://clang-analyzer.llvm.org/">Clang Static Analyzer</a>
      <li><a href="#clang-sa-virt-calls">Warn if virtual calls are made from
          constructors or destructors</a>
      </li>
      <li><a href="#clang-sa-atomics">Model C++11 and C11 atomics in the
          analyzer</a>
      </li>
      <li><a href="#clang-sa-escape-analysis">Implement fast escape analysis for
          clang AST</a>
      </li>
    </ul>
    <ul><a href="http://compiler-rt.llvm.org/">Compiler-rt</a>
      <li><a href="#compiler-rt-port-to-other-platforms">Port compiler-rt
          components to other platforms</a>
      </li>
    </ul>
    <ul><a href="http://lldb.llvm.org/">LLDB</a>
      <li><a href="#lldb-reimplement-lldb-mi">Reimplement lldb-mi on top of the
          LLDB public API</a>
      </li>
    </ul>
    <ul><a href="http://lld.llvm.org/">LLD</a>
      <li><a href="#lld_layout">Improve Code Layout</a>
      </li>
    </ul>
	
  </li>
  <li><a href="#what">What is this?</a></li>
  <li><a href="#subprojects">LLVM Subprojects: Clang and more</a></li>
  <li><a href="#improving">Improving the current system</a>
  <ol>
    <li><a href="#target-desc">Factor out target descriptions</a></li>
    <li><a href="#code-cleanups">Implementing Code Cleanup bugs</a></li>
    <li><a href="#programs">Compile programs with the LLVM Compiler</a></li>
    <li><a href="#llvmtest">Add programs to the llvm-test suite</a></li>
    <li><a href="#benchmark">Benchmark the LLVM compiler</a></li>
    <li><a href="#statistics">Benchmark Statistics and Warning System</a></li>
    <li><a href="#coverage">Improving Coverage Reports</a></li>
    <li><a href="#misc_imp">Miscellaneous Improvements</a></li>
  </ol></li>

  <li><a href="#new">Adding new capabilities to LLVM</a>
  <ol>
    <li><a href="#llvm_ir">Extend the LLVM intermediate representation</a></li>
    <li><a href="#pointeranalysis">Pointer and Alias Analysis</a></li>
    <li><a href="#profileguided">Profile-Guided Optimization</a></li>
    <li><a href="#compaction">Code Compaction</a></li>
    <li><a href="#xforms">New Transformations and Analyses</a></li>
    <li><a href="#codegen">Code Generator Improvements</a></li>
    <li><a href="#misc_new">Miscellaneous Additions</a></li>
  </ol></li>

  <li><a href="#using">Project using LLVM</a>
  <ol>
    <li><a href="#machinemodulepass">Add a MachineModulePass</a></li>
    <li><a href="#encodeanalysis">Encode Analysis Results in MachineInstr IR</a></li>
    <li><a href="#codelayoutjit">Code Layout in the LLVM JIT</a></li>
    <li><a href="#fieldlayout">Improved Structure Splitting and Field Reordering</a></li>
    <li><a href="#slimmer">Finish the Slimmer Project</a></li>
  </ol></li>
</ul>

<div class="doc_author">
  <p>Written by the <a href="http://llvm.org/">LLVM Team</a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc17">Google Summer of Code 2017</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>
Welcome prospective Google Summer of Code 2017 Students! This document is your starting point to finding interesting and important projects for LLVM, Clang, and other related sub-projects. This list of projects is not just developed for Google Summer of Code, but open projects that really need developers to work on and are very beneficial for the LLVM community. </p>

<p>We encourage you to look through this list and see which projects excite you and match well with your skill set. We also invite proposals not on this list. However, you must propose your idea to the LLVM community through our developers' mailing list (llvm-dev@lists.llvm.org or specific subproject mailing list). Feedback from the community is a requirement for your proposal to be considered and hopefully accepted.
</p>

<p>The LLVM project has participated in Google Summer of Code for several years and has had some very successful projects. We hope that this year is no different and look forward to hearing your proposals. For information on how to submit a proposal, please visit the Google Summer of Code main <a href="https://developers.google.com/open-source/gsoc/">website.</a></p>




<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="bitcode_fuzzing">Fuzzing the Bitcode reader</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_overhead">Improve optimizer overhead with debug info</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  The optimizer is 25-30% slower when debug info are enabled, it'd be nice
	  to track all the places where we don't do a good job about ignoring them!
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="thinlto_global">ThinLTO: propagating more global informations across 
	  the program for more powerful optimizations!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  ThinLTO is a cool new technology to perform Link-Time Optimization (see
	  http://llvm.org/devmtg/2016-11/#talk12 for more info). It is fairly new
	  and there are multiple improvements about cross-module optimizations that
	  can be made there.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_codegen_mismatch"></a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Adding Debug Info (compiling with `clang -g`) shouldn't change the
	  generated code at all. Unfortunately we have bugsâ€¦ These are usually not
	  too hard to fix and a good way to discover new part of the codebase! A
	  starting point could be the test-suite. We suggest building object files
	  both ways and disassembling the text sections, which will give cleaner
	  diffs than comparing .s files.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="hashmap_codegen_mismatch">Changing the iteration order of unordered
	  datastructures should not change the generated code.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="opt_remarks">We need better optimization remarks!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  See http://llvm.org/devmtg/2016-11/#talk15 for a starting point. There are
	  many areas in the compiler that need work to integrate there (ThinLTO for
	  example). 
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvmir_dump">Smarter way of dumping LLVM IR with -emit-after-all</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Smarter way of dumping LLVM ir with -emit-after-all - dump only if it
	  differs from last pass. Maybe small color the IR?
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="codegen_testing">Improve code generation testing</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  After instruction selection LLVM uses the MI (Machine Instruction)
	  representation for programs. We recently added support for reading and
	  writing this representation to disk
	  (http://llvm.org/docs/MIRLangRef.html). Usage of this format for writing
	  tests is growing and so is the desire to improve the format, tools and
	  workflow. Improvements would be welcome:

	  <ul><li>Create a single consistent format instead of the current mix of
		  YAML + IR + MIR</ul></li>
	  <ul><li>Do not print unnecessary information (we often print default
		  values where the reader could deduce them)</ul></li>
	  <ul><li>The format of things like MachineInstr/MachineBasicBlock::dump()
		  should be the same or very close to the .mir format => change the dump
		  functions.</ul></li>
	  <ul><li>Allow the representation to deduce successors of a basic block in
		  common cases</ul></li>
	  <ul><li>Allow symbolic names instead of just numbers for virtual
		  registers</ul></li>
	  <ul><li>Helper passes: Strip IR information, rename blocks and values, 
		  debug information, ...</ul></li>
	  <ul><li>Create a bugpoint mode (or a new tool) to reduce .mir test cases</ul></li>
	  <ul><li>Write recommendations and guides for .mir based tests</ul></li>
  </p>
  
   <p><b>Contact Person:</b>Matthias Braun</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-template-instantiation-sugar">Extend clang AST to provide
    information for the type as written in template instantiations.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    When instantiating a template, the template arguments are canonicalized
    before being substituted into the template pattern. Clang does not preserve
    type sugar when subsequently accessing members of the instantiation.

    <pre>
    std::vector&lt;std::string&gt; vs;
    int n = vs.front(); // bad diagnostic: [...] aka 'std::basic_string&lt;char&gt;' [...]

    template&lt;typename T&gt; struct Id { typedef T type; };
    Id&lt;size_t&gt;::type // just 'unsigned long', 'size_t' sugar has been lost
    </pre>

    Clang should "re-sugar" the type when performing member access on a class
    template specialization, based on the type sugar of the accessed
    specialization. The type of vs.front() should be std::string, not
    std::basic_string&lt;char, [...]&gt;.
    <br /> <br />
    Suggested design approach: add a new type node to represent template
    argument sugar, and implicitly create an instance of this node whenever a
    member of a class template specialization is accessed. When performing a
    single-step desugar of this node, lazily create the desugared representation
    by propagating the sugared template arguments onto inner type nodes (and in
    particular, replacing Subst*Parm nodes with the corresponding sugar). When
    printing the type for diagnostic purposes, use the annotated type sugar to
    print the type as originally written.
    <br /> <br />
    For good results, template argument deduction will also need to be able to
    deduce type sugar (and reconcile cases where the same type is deduced twice
    with different sugar).
  </p>

  <p><b>Expected results: </b>
    Diagnostics preserve type sugar even when accessing members of a template
    specialization. T&lt;unsigned long&gt; and T&lt;size_t&gt; are still the
    same type and the same template instantiation, but
    T&lt;unsigned long&gt;::type single-step desugars to 'unsigned long' and
    T&lt;size_t&gt;::type single-step desugars to 'size_t'.

  <p><b>Confirmed Mentor:</b>Vassil Vassilev, Richard Smith</p>

  <p><b>Desirable skills:</b>
    Good knowledge of clang API, clang's AST, intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-shell-autocompletion-support">Shell auto-completion support for
    clang.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Bash and other shells support typing a partial command and then
    automatically completing it for the user (or at least providing suggestions
    how to complete) when pressing the tab key. This is usually only supported
    for popular programs such as package managers (e.g. pressing tab after
    typing "apt-get install late" queries the APT package database and lists all
    packages that start with "late"). As of now clang's frontend isn't supported
    by any common shell.

    <br /> <br />
    Suggested design approach: The main goal is to support variety of terminals.
    It would be preferable to keep each shell plugin minimal, enabling easy
    addition of new plugins. The implementation ought to extend the clang driver
    switches with a flag to request auto-completion of a partial shell command.
    <br /> <br />

    The final auto-completion support should contain features such as:
    <ul>
      <li>Searching/correcting all flags. For example:
        <ul>
          <li>typing <code>clang -tri<i>[tab]</i></code> should complete to
            <code>-trigraphs</code>
          </li>
          <li>typing <code>clang -cc1 -dump-decls<i>[tab]</i></code> should
            correct <code>-dump-decls</code> to <code>-dump-deserialized-decls</code>
          </li>
        </ul>
      </li>
      <li>Searching for valid arguments for the flags. For example:
        <ul>
          <li>typing <code>clang -cc1 -analyze -analyzer-checker=<i>[tab]</i> -fsyntax-only</code>
            should list all available static analyzers (eg. core.DivideZero)
          </li>
          <li>typing <code>clang -std=<i>[tab]</i></code> should list the
            available language standards.
          </li>
        </ul>
      </li>
      <li>When the auto-completion for a partial command is ambiguous, all
        possible completions should be displayed with the relevant description
        from the "--help" output beside it (<a href="https://www.pablumfication.co.uk/wp-content/uploads/2010/02/fish-lsAutocompleteArguments.jpg">
          example of this in fish with the command "ls"</a>).
      </li>      
    </ul>
  </p>

  <p><b>Expected results: </b>
    Bash supports abovementioned auto-complete examples on at least OS X and
    Linux.
  <p><b>Confirmed Mentor:</b>Vassil Vassilev, Raphael Isemann</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++ and shell scripting, Intermediate knowledge of
    the clang driver.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-diff-tool">Clang-based C/C++ diff tool.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Every developer has to interact with diff tools daily. The algorithms are
    usually based on detecting "longest common subsequences", which is agnostic
    to the file type content. A tool that would understand the structure of the
    code may provide a better diff experience by being robust against, for
    example, clang-format changes.
  </p>
  <p><b>Confirmed Mentor:</b>Mehdi Amini</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Static Analyzer</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-virt-calls">Warn if virtual calls are made from constructors
    or destructors.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
    Implement a path-sensitive checker that warns if virtual calls are made from
    constructors and destructors, which is not valid in case of pure virtual
    calls and could be a sign of user error in <a href="https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors">non-pure calls</a>.
    <br />
    The current virtual calls checker, implemented in VirtualCallChecker.cpp,
    needs to be re-implemented in a path-sensitive way.  The lack of
    path-sensitive reasoning may result in false positives in the
    inter-procedural mode, which is disabled now for that reason.
    The false positives could happen when a called function uses a member
    variable flag to track whether initialization is complete and relies on the
    flag to ensure that the virtual member function is not called during
    initialization. Further, the path diagnostic should be used to highlight
    both the virtual call and the path from the constructor. Last, we will need
    to evaluate if the warning should be issued for both calls to pure virtual
    functions (which is always an error) and non-pure virtual functions (which
    is more of a code smell and may be a false positive). 
  </p>
  <p><b>Confirmed Mentor:</b>Anna Zaks</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-atomics">Model C++11 and C11 atomics in the analyzer.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
    Enhance the clang static analyzer by adding models of C++11 and C11 atomic
    operations, such as std::atomic_compare_exchange_*. Currently, these
    operations are being treated opaquely, which results in loss of precision
    when analyzing the code that uses these instructions. To address the
    problem, one would need to programmatically construct AST that simulates
    these APIs to the BodyFarm of the analyzer. BodyFarm is the API used for
    modeling system APIs. Finally, the work would also include writing tests
    for the various APIs and checking that the analyzer correctly models
    atomics. 
  </p>
  <p><b>Confirmed Mentor:</b>Anna Zaks</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-escape-analysis">Implement fast escape analysis for
    clang AST.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
    The static analyzer and the compiler that operate on top of clang AST could
    use the results of a fast pointer analysis such as "Points-to analysis in
    almost linear time" by Bjarne Steensgaard. 
  </p>
  <p><b>Confirmed Mentor:</b>Devin Coughlin</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Compiler-rt</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="compiler-rt-port-to-other-platforms">Port compiler-rt components to
    other platforms.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
    Many of the projects in compiler-rt are only supported on Linux.
    <br />
    Here are some examples: CFI, DFSan, XSan, LSan, XRay. Porting any of them
    to other platforms, for example, Mac OS, would be great!
  </p>
  <p><b>Confirmed Mentor:</b>Kuba Mracek, Anna Zaks</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLDB</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-reimplement-lldb-mi">Reimplement lldb-mi on top of the LLDB
    public API.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
    lldb-mi implements a machine-readable interface that is supported by many
    IDEs. The current support is very incomplete and isn't using the right
    abstraction layer. Instead of scraping LLDB's textual output, it should be
    using the data structures provided by the public API.
  </p>
  <p><b>Confirmed Mentor:</b>Adrian Prantl, Greg Clayton</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLD</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lld_layout">Improve Code Layout</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text"> 	 
  <p><b>Description of the project: </b>
	The goal for the project is trying to improve the layout/performances of the
	generated executable. The primary object format considered for the project
	is ELF but this can be extended to other object formats. The project will
	touch both LLVM and lld.
	<ul>
		<li>Warm-up: lld already provides an option to (--symbol-ordering file)
			which takes a symbol ordering file (presumably collected from a
			profiler) and builds a layout. This aims to reduce startup times. It
			would be nice to provide scripts to profile the applications/process
			various profilers output to produce an order file/evaluate the
			impact of the feature (as it has been tested only on a small class
			of applications). There's already some work in the area but nothing
			has been integrated in the LLVM build system for ELF. Ideally a
			motivated student would do the benchmarking/analysis before the GSoC
			starts to familiarize with the problem.</li>
		<li>The meat: Use/extend profile informations generated by LLVM to help
			the linker laying out functions. An obvious way (what gcc uses, [1])
			is to pass values to the linker using special `.note` sections. The
			linker then can reconstruct the call graph and apply an algorithm
			like the one described in [2] (this is just a starting point, other
			alternatives can be explored).</li>
	</ul>
  </p>
  <p>
	Possible extension: Xray can be used to provide data (it's unclear whether
	this is feasible easily, see David's comment in [3]).
  </p>
  <p><b>Contact Person:</b>Davide Italiano</p>
  
  <ul>
    <li>[1] http://sourceware.org/ml/binutils/2011-03/msg00043.html</li>
    <li>[2] http://dl.acm.org/citation.cfm?id=93550</li>
    <li>[3] http://lists.llvm.org/pipermail/llvm-dev/2017-January/109114.html</li>
  </ul>
</div>


<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="what">What is this?</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>This document is meant to be a sort of "big TODO list" for LLVM.  Each
project in this document is something that would be useful for LLVM to have, and
would also be a great way to get familiar with the system.  Some of these
projects are small and self-contained, which may be implemented in a couple of
days, others are larger.  Several of these projects may lead to interesting
research projects in their own right.  In any case, we welcome all
contributions.</p>

<p>If you are thinking about tackling one of these projects, please send a mail
to the <a href="http://lists.llvm.org/mailman/listinfo/llvm-dev">LLVM
Developer's</a> mailing list, so that we know the project is being worked on.
Additionally this is a good way to get more information about a specific project
or to suggest other projects to add to this page.
</p>

<p>The projects in this page are open-ended. More specific projects are
filed as unassigned enhancements in the <a href="http://bugs.llvm.org/">
LLVM bug tracker</a>. See the <a href="http://bugs.llvm.org/buglist.cgi?keywords_type=allwords&amp;keywords=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_severity=enhancement&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=unassigned">list of currently outstanding issues</a> if you wish to help improve LLVM.</p>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="subprojects">LLVM Subprojects: Clang and More</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>In addition to hacking on the main LLVM project, LLVM has several subprojects,
   including Clang and others.  If you are interested in working on these, please
   see their "Open projects" page:</p>

<ul>
<li>The <a href="http://clang.llvm.org/OpenProjects.html">Clang Open
    Projects</a> list.</li>
<li>The <a href="http://polly.llvm.org/projects.html">Polly Open
    Projects</a> list.</li>
<li>The <a href="http://sva.cs.illinois.edu/projects.html">SAFECode Open
    Projects</a> list.</li>
</ul>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="improving">Improving the current system</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Improvements to the current infrastructure are always very welcome and tend
to be fairly straight-forward to implement.  Here are some of the key areas that
can use improvement...</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="target-desc">Factor out target descriptions</a>
</div>

<div class="www_text">

<p>Currently, both Clang and LLVM have a separate target description infrastructure,
with some features duplicated, others "shared" (in the sense that Clang has to create
a full LLVM target description to query specific information).</p>

<p>This separation has grown in parallel, since in the beginning they were quite
different and served disparate purposes. But as the compiler evolved, more and
more features had to be shared between the two so that the compiler would behave
properly. An example is when targets have default features on speficic configurations
that don't have flags for. If the back-end has a different "default" behaviour
than the front-end and the latter has no way of enforcing behaviour, it simply
won't work.</p>

<p>Of course, an alternative would be to create flags for all little quirks, but
first, Clang is not the only front-end or tool that uses LLVM's middle/back ends,
and second, that's what "default behaviour" is there for, so we'd be missing the
point.</p>

<p>Several ideas have been floating around to fix the Clang driver WRT recognizing
architectures, features and so on (table-gen it, user-specific configuration files,
etc) but none of them touch the critical issue: sharing that information with the
back-end.</p>

<p>Recently, the idea to factor out the target description infrastructure from
both Clang and LLVM into its own library that both use, has been floating around.
This would make sure that all defaults, flags and behaviour are shared, but would
also reduce the complexity (and thus the cost of maintenance) a lot. That would
also allow all tools (lli, llc, lld, lldb, etc) to have the same behaviour
across the board.</p>

<p>The main challenges are:</p>

<ul>
  <li>To make sure the transition doesn't destroy the delicate balance on any
  target, as some defaults are implicit and, some times, unknown.</li>
  <li>To be able to migrate one target at a time, one tool at a time and still
  keep the old infrastructure intact.</li>
  <li>To make it easy for detecting target's features for both front-end and
  back-end features, and to merge both into a coherent set of properties.</li>
  <li>To provide a bridge to the new system for tools that haven't migrated,
  especially the off-the-tree ones, that will need some time (one release,
  at least) to migrate..</li>
</ul>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="code-cleanups">Implementing Code Cleanup bugs</a>
</div>

<div class="www_text">

<p>
The <a href="http://bugs.llvm.org/">LLVM bug tracker</a> occasionally
has <a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=code-cleanup&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">"code-cleanup" bugs</a> filed in it.
Taking one of these and fixing it is a good way to get your feet wet in the
LLVM code and discover how some of its components work.  Some of these include
some major IR redesign work, which is high-impact because it can simplify a lot
of things in the optimizer.
</p>

<p>
Some specific ones that would be great to have:

<ul>
<li><a href="http://llvm.org/PR10367">Fix the design of GlobalAlias to not require dest type to match source type</a></li>
<li><a href="http://llvm.org/PR10368">Redesign ConstantExpr's</a></li>
<li><a href="http://llvm.org/PR11944">Static constructors should be purged from LLVM</a></li>
</ul>
</p>

<p>Additionally, there are performance improvements in LLVM that need to get
fixed. These are marked with the <tt>slow-compile</tt> keyword. Use
<a href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=slow-compile&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=Bugs+I+Fixed&amp;newqueryname=&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">this Bugzilla query</a>
to find them.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvmtest">Add programs to the llvm-test testsuite</a>
</div>

<div class="www_text">

<p>
The <a href="docs/TestingGuide.html#wholeprograms">llvm-test</a> testsuite is
a large collection of programs we use for nightly testing of generated code
performance, compile times, correctness, etc.  Having a large testsuite gives
us a lot of coverage of programs and enables us to spot and improve any
problem areas in the compiler.</p>

<p>
One extremely useful task, which does not require in-depth knowledge of
compilers, would be to extend our testsuite to include <a href=
"http://nondot.org/sabre/LLVMNotes/#benchmarks">new programs and benchmarks</a>.
In particular, we are interested in cpu-intensive programs that have few
library dependencies, produce some output that can be used for correctness
testing, and that are redistributable in source form.  Many different programs
are suitable, for example, see <a
href="http://nondot.org/sabre/LLVMNotes/#benchmarks">this list</a> for some
potential candidates.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="programs">Compile programs with the LLVM Compiler</a>
</div>

<div class="www_text">

<p>We are always looking for new testcases and benchmarks for use with LLVM.  In
particular, it is useful to try compiling your favorite C source code with LLVM.
If it doesn't compile, try to figure out why or report it to the <a
href="http://lists.llvm.org/pipermail/llvm-bugs/">llvm-bugs</a> list.  If you
get the program to compile, it would be extremely useful to convert the build
system to be compatible with the LLVM Programs testsuite so that we can check it
into SVN and the automated tester can use it to track progress of the
compiler.</p>

<p>When testing a code, try running it with a variety of optimizations, and with
all the back-ends: CBE, llc, and lli.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="benchmark">Benchmark the LLVM compiler</a>
</div>

<div class="www_text">

<p>Find benchmarks either using our <a
href="http://llvm.org/nightlytest/">test results</a> or on your own,
where LLVM code generators do not produce optimal code or simply where another
compiler produces better code.  Try to minimize the test case that demonstrates
the issue.  Then, either <a href="http://bugs.llvm.org/">submit a
bug</a> with your testcase and the code that LLVM produces vs. the code that it
<em>should</em> produce, or even better, see if you can improve the code
generator and submit a patch.  The basic idea is that it's generally quite easy
for us to fix performance problems if we know about them, but we generally don't
have the resources to go finding out why performance is bad.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="statistics">Benchmark Statistics and Warning System</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/perf/db_default/v4/nts/recent_activity'>
LNT perf database</a> has some nice features like detect moving average,
standard deviations, variations, etc. But the report page give too much emphasis
on the individual variation (where noise can be higher than signal), eg.
<a href='http://llvm.org/perf/db_default/v4/nts/graph?plot.0=10.341.3&highlight_run=8943'>
this case</a>.</p>

<p>The first part of the project would be to create an analysis tool that would
track moving averages and report:
<ul>
 <li>If the current result is higher/lower than the previous moving average by
     more than (configurable) S standard deviations</li>
 <li>If the current moving average is more than S standard deviations of the
     Base run</li>
 <li>If the last A moving averages are in constant increase/decrease of more
     than P percent</li>
</ul>

<p>The second part would be to create a web page which would show all related
benchmarks (possibly configurable, like a dashboard) and show the basic statistics
with red/yellow/green colour codes to show status and links to more detailed
analysis of each benchmark.</p>

<p>A possible third part would be to be able to automatically cross reference
different builds, so that if you group them by architecture/compiler/number
of CPUs, this automated tool would understand that the changes are more common
to one particular group.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="coverage">Improving Coverage Reports</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/reports/coverage/'>
LLVM Coverage Report</a> has a nice interface to show what source lines are
covered by the tests, but it doesn't mentions which tests, which revision and
what architecture is covered.</p>

<p>A project to renovate LCOV would involve:
<ul>
 <li>Making it run on a buildbot, so that we know what commits / architectures
     are covered</li>
 <li>Update the web page to show that information</li>
 <li>Develop a system that would report every buildbot build into the web page
     in a searchable database, like LNT</li>
</ul>

<p>Another idea is to enable the test suite to run all built backends, not just
   the host architecture, so that coverage report can be built in a fast machine
   and have one report per commit without needing to update the buildbots.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_imp">Miscellaneous Improvements</a>
</div>

<div class="www_text">

<ol>

<li>Completely rewrite bugpoint.  In addition to being a mess, bugpoint suffers
from a number of problems where it will "lose" a bug when reducing.  It should
be rewritten from scratch to solve these and other problems.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=2116">Add support for
transactions to the PassManager</a> for improved bugpoint.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=539">Improve bugpoint to
support running tests in parallel on MP machines</a>.</li>
<li>Add MC assembler/disassembler and JIT support to the SPARC port.</li>
<li>Move more optimizations out of the <tt>-instcombine</tt> pass and into
InstructionSimplify.  The optimizations that should be moved are those that
do not create new instructions, for example turning <tt>sub i32 %x, 0</tt>
into <tt>%x</tt>.  Many passes use InstructionSimplify to clean up code as
they go, so making it smarter can result in improvements all over the place.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="new">Adding new capabilities to LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Sometimes creating new things is more fun than improving existing things.
These projects tend to be more involved and perhaps require more work, but can
also be very rewarding.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvm_ir">Extend the LLVM intermediate representation</a>
</div>

<div class="www_text">

<p>Many proposed <a href="http://nondot.org/sabre/LLVMNotes/">extensions and
improvements to LLVM core</a> are awaiting design and implementation.</p>

<ol>
<li><a href="http://nondot.org/sabre/LLVMNotes/DebugInfoImprovements.txt">Improvements
for Debug Information Generation</a></li>
<li><a href="http://llvm.org/PR1269">EH support for non-call exceptions</a></li>
<li>Many ideas for feature requests are stored in LLVM bugzilla.  Just <a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=new-feature&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=All+PRs&amp;newqueryname=&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">search for bugs with a "new-feature" keyword</a>.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="pointeranalysis">Pointer and Alias Analysis</a>
</div>

<div class="www_text">

<p>We have a <a href="docs/AliasAnalysis.html">strong base for development</a> of
both pointer analysis based optimizations as well as pointer analyses
themselves.  It seems natural to want to take advantage of this:</p>

<ol>
<li>The globals mod/ref pass basically does really simple and cheap
bottom-up context sensitive alias analysis.  It being simple and cheap
are really important, but there are simple things that we could do to
better capture the effects of functions that access pointer
arguments.  This can be really important for C++ methods, which spend
lots of time accessing pointers off 'this'.</li>

<li>The alias analysis API supports the getModRefBehavior method, which
allows the implementation to give details analysis of the functions.
For example, we could implement <a href="http://llvm.org/PR1604">full knowledge
of printf/scanf</a> side effects, which would be useful.  This feature is in
place but not being used for anything right now.</li>
<li>We need some way to reason about errno.  Consider a loop like this:

<pre>
    for ()
      x += sqrt(loopinvariant);
</pre>

<p>We'd like to transform this into:</p>

<pre>
    t = sqrt(loopinvariant);
    for ()
      x += t;
</pre>

<p>This transformation is safe, because the value of errno isn't
otherwise changed in the loop and the exit value of errno from the
loop is the same.  We currently can't do this, because sqrt clobbers
errno, so it isn't "readonly" or "readnone" and we don't have a good
way to model this.</p>

<p>The hard part of this project is figuring out how to describe errno
in the optimizer: each libc #defines errno to something different it
seems.  Maybe the solution is to have a __builtin_errno_addr() or
something and change sys headers to use it.</p>

<li>There are lots of ways to optimize out and <a
href="http://llvm.org/PR452">improve handling of
memcpy/memset</a>.</li>

</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="profileguided">Profile-Guided Optimization</a>
</div>

<div class="www_text">

<p>We now have a unified infrastructure for writing profile-guided
transformations, which will work either at offline-compile-time or in the JIT,
but we don't have many transformations.  We would welcome new profile-guided
transformations as well as improvements to the current profiling system.
</p>

<p>Ideas for profile-guided transformations:</p>

<ol>
<li>Superblock formation (with many optimizations)</li>
<li>Loop unrolling/peeling</li>
<li>Profile directed inlining</li>
<li>Code layout</li>
<li>...</li>
</ol>

<p>Improvements to the existing support:</p>

<ol>
<li>The current block and edge profiling code that gets inserted is very simple
and inefficient.  Through the use of control-dependence information, many fewer
counters could be inserted into the code.  Also, if the execution count of a
loop is known to be a compile-time or runtime constant, all of the counters in
the loop could be avoided.</li>

<li>You could implement one of the "static profiling" algorithms which analyze a
piece of code an make educated guesses about the relative execution frequencies
of various parts of the code.</li>

<li>You could add path profiling support, or adapt the existing LLVM path
profiling code to work with the generic profiling interfaces.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="compaction">Code Compaction</a>
</div>

<div class="www_text">
<p>LLVM aggressively optimizes for performance, but does not yet optimize for code size.
With a new ARM backend, there is increasing interest in using LLVM for embedded systems
where code size is more of an issue.
</p>

<p>Someone interested in working on implementing code compaction in LLVM might want to read
<a href="http://citeseer.ist.psu.edu/425696.html">this</a> article, describing using
link-time optimizations for code size optimization.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="xforms">New Transformations and Analyses</a>
</div>

<div class="www_text">

<ol>
  <li>Implement a Loop Dependence Analysis Infrastructure<br>
    - Design some way to represent and query dep analysis</li>
  <li>Value range propagation pass</li>
  <li>More fun with loops:
    <a href="http://www.cs.ualberta.ca/~amaral/cascon/CDP04/tal.html">
      Predictive Commoning
    </a>
  </li>
  <li>Type inference (aka. devirtualization)</li>
  <li><a href="http://nondot.org/sabre/LLVMNotes/BuiltinUnreachable.txt">Value
      assertions</a> (also <a href="http://llvm.org/PR810">PR810</a>).</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codegen">Code Generator Improvements</a>
</div>

<div class="www_text">

<ol>
<li>Generalize target-specific backend passes that could be target-independent,
    by adding necessary target hooks and making sure all IR/MI features (such as
    register masks and predicated instructions) are properly handled. Enable these
    for other targets where doing so is demonstrably beneficial.
    For example:
      <ol><li>lib/Target/Hexagon/RDF*</li>
          <li>lib/Target/AArch64/AArch64AddressTypePromotion.cpp</li>
     </ol>
    </li>
<li>Merge the delay slot filling logic that is duplicated into (at least)
    the Sparc and Mips backends into a single target independent pass.
     Likewise, the branch shortening logic in several targets should be merged
     together into one pass.</li>
<li>Implement 'stack slot coloring' to allocate two frame indexes to the same
    stack offset if their live ranges don't overlap.  This can reuse a bunch of
    analysis machinery from LiveIntervals.  Making the stack smaller is good
    for cache use and very important on targets where loads have limited
    displacement like ppc, thumb, mips, sparc, etc.  This should be done as
    a pass before prolog epilog insertion.  This is now done for register
    allocator temporaries, but not for allocas.</li>
<li>Implement 'shrink wrapping', which is the intelligent placement of callee
    saved register save/restores.  Right now PrologEpilogInsertion always saves
    every (modified) callee save reg in the prolog and restores it in the
    epilog.  However, some paths through a function (e.g. an early exit) may
    not use all regs.  Sinking the save down the CFG avoids useless work on
    these paths. Work has started on this, please inquire on llvm-dev.</li>
<li>Implement interprocedural register allocation. The CallGraphSCCPass can be
    used to implement a bottom-up analysis that will determine the *actual*
    registers clobbered by a function. Use the pass to fine tune register usage
    in callers based on *actual* registers used by the callee.</li>
<li>Add support for 16-bit x86 assembly and real mode to the assembler and
    disassembler, for use by BIOS code. This includes both 16-bit instruction
    encodings as well as privileged instructions (lgdt, lldt, ltr, lmsw, clts,
    invd, invlpg, wbinvd, hlt, rdmsr, wrmsr, rdpmc, rdtsc) and the control and
    debug registers.
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_new">Miscellaneous Additions</a>
</div>

<div class="www_text">

<ol>
<li>Port the <a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">Bigloo</A>
Scheme compiler, from Manuel Serrano at INRIA Sophia-Antipolis, to
output LLVM bytecode. It seems that it can already output .NET
bytecode, JVM bytecode, and C, so LLVM would ostensibly be another good
candidate.</li>
<li>Write a new frontend for some other language (Java? OCaml? Forth?)</li>
<li>Random test vector generator: Use a C grammar to generate random C code,
e.g., <a href="http://code.google.com/p/quest-tester/">quest</a>;
run it through llvm-gcc, then run a random set of passes on it using opt.
Try to crash <tt><a href="/docs/CommandGuide/html/opt.html">opt</a></tt>. When
<tt>opt</tt> crashes, use <tt><a
href="/docs/CommandGuide/html/bugpoint.html">bugpoint</a></tt> to reduce the
test case and post it to a website or mailing list.  Repeat ad infinitum.</li>
<li>Add sandbox features to the Interpreter: catch invalid memory accesses,
  potentially unsafe operations (access via arbitrary memory pointer) etc.
</li>
<li>Port <a href="http://valgrind.org">Valgrind</a> to use LLVM code generation
  and optimization passes instead of its own.</li>
<li>Write LLVM IR level debugger (extend Interpreter?)</li>
<li>Write an LLVM Superoptimizer.  It would be interesting to take ideas from
    this superoptimizer for x86:
<a href="http://theory.stanford.edu/~aiken/publications/papers/asplos06.pdf">paper #1</a> and <a href="http://theory.stanford.edu/~sbansal/superoptimizer.html">paper #2</a> and adapt them to run on LLVM code.<p>

It would seem that operating on LLVM code would save a lot of time
because its semantics are much simpler than x86.  The cost of operating
on LLVM is that target-specific tricks would be missed.<p>

The outcome would be a new LLVM pass that subsumes at least the
instruction combiner, and probably a few other passes as well.  Benefits
would include not missing cases missed by the current combiner and also
more easily adapting to changes in the LLVM IR.<p>

All previous superoptimizers have worked on linear sequences of code.
It would seem much better to operate on small subgraphs of the program
dependency graph.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="using">Projects using LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

  <p>
  In addition to projects that enhance the existing LLVM infrastructure, there
  are projects that improve software that uses, but is not included with, the
  LLVM compiler infrastructure.  These projects include open-source software
  projects and research projects that use LLVM.  Like projects that enhance the
  core LLVM infrastructure, these projects are often challenging and rewarding.
  </p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="encodeanalysis">Encode Analysis Results in MachineInstr IR</a>
</div>

<div class="www_text">
  <p>
  At least one project (and probably more) needs to use analysis information
  (such as call graph analysis) from within a MachineFunctionPass.  However,
  most analysis passes operate at the LLVM IR level.  In some cases, a value
  (e.g., a function pointer) cannot be mapped from the MachineInstr level back
  to the LLVM IR level reliably, making the use of existing LLVM analysis
  passes from within a MachineFunctionPass impossible (or at least brittle).
  </p>

  <p>
  This project is to encode analysis information from the LLVM IR level into
  the MachineInstr IR when it is generated so that it is available to a
  MachineFunctionPass.  The exemplar is call graph analysis (useful for
  control-flow integrity instrumentation, analysis of code reuse defenses, and
  gadget compilers); however, other LLVM analyses may be useful.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codelayoutjit">Code Layout in the LLVM JIT</a>
</div>

<div class="www_text">
  <p>
  Implement an on-demand function relocator in the LLVM JIT. This can help
  improve code locality using runtime profiling information. The idea is to use
  a relocation table for every function.  The relocation entries need to be
  updated upon every function relocation (take a look at
  <a href="https://people.cs.umass.edu/~emery/pubs/stabilizer-asplos13.pdf">
  this article</a>).
  A (per-function) basic block reordering would be a useful extension.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="fieldlayout">Improved Structure Splitting and Field Reordering</a>
</div>

<div class="www_text">
  <p>
  The goal of this project is to implement better data layout optimizations
  using the model of reference affinity.  This
  <a href="http://www.cs.rochester.edu/~cding/Documents/Publications/pldi04.pdf">
  paper</a>
  provides some background information.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="slimmer">Finish the Slimmer Project</a>
</div>

<div class="www_text">
  <p>
  Slimmer is a prototype tool, built using LLVM, that uses dynamic analysis to
  find potential performance bugs in programs.  Development on Slimmer started
  during Google Summer of Code in 2015 and resulted in an initial prototype,
  but evaluation of the prototype and improvements to make it portable and
  robust are still needed.  This project would have a student pick up and
  finish the Slimmer work.  The source code of Slimmer and
  its current documentation can be found at its
  <a href="https://github.com/james0zan/Slimmer">Github</a> web page.
  </p>
</div>

<!-- *********************************************************************** -->

<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"></a>

  <a href="http://llvm.org">LLVM Compiler Infrastructure</a><br>
</address>

<!--#include virtual="footer.incl" -->
