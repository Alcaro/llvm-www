<!--#include virtual="../../header.incl" -->
<div class="www_sectiontitle">2014 LLVM Developers' Meeting</div>
<table>
        <tr><td valign="top">
<ol>
        <li><a href="#about">About</a></li>
        <li><a href="#registration">Registration</a></li>
        <li><a href="#agenda1">October 28 - Meeting Agenda</a></li>
         <li><a href="#agenda2">October 29 - Meeting Agenda</a></li>
        <li><a href="#abstracts">Talk Abstracts</a></li>
        <li><a href="#light">Lightning Talk Abstracts</a></li>
        <li><a href="#tutorials">Tutorial Abstracts</a></li>
        <li><a href="#bof">BoF Abstracts</a></li>
        <li><a href="#poster">Poster Abstracts</a></li>
        <li><a href="#logistics">Logistics</a></li>
</ol>
</td><td>
<ul>
  <li><b>What</b>: The eighth meeting of LLVM Developers and Users.</li>
  <li><b>When</b>: October 28-29, 2014</li>
  <li><b>Where</b>: DoubleTree by Hilton - San Jose, CA</li>
</ul>
</td></tr></table>

<p>A huge thank you to our sponsors!</p>

<p><h1>Diamond Sponsors:</h1>
<h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.apple.com">Apple</a></h1>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="quic_web_logo.jpg">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.quicinc.com">QuIC</a></h1>
</p>

<p><h1>Platinum Sponsors:</h1>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img width="18%" src="Google-logo_420_color_2x.png">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://google.com">Google</a>
</p><p>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img width="13%" src="SCE_C_pos.jpg">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://us.playstation.com/corporate/about/">Sony Computer Entertainment America</a>


<h1>Gold Sponsors:</h1> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interested in being a Gold Level Sponsor? See <a href="#sponsor">below.</a></p>

<h1>Silver Sponsors: </h1>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img width="18%" src="HSAFoundation-FINAL.PNG">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.hsafoundation.com">HSA Foundation</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img width="20%" src="MentorEmbedded_brand_legal.png">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.mentor.com/embedded">Mentor Embedded</a></p>

<h1>Bronze Sponsors:</h1>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img width="17%" src="ARMCompanyLogo.jpg">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.arm.com">ARM</a>
</p>
<div class="www_sectiontitle" id="about">About</div>
<p>The LLVM Foundation announces the eighth annual bay area LLVM Developers' Meeting will be held October 28th and 29th in San Jose, CA.</p>

<p>
This year the conference will be 2 full days that include technical talks, BoFs, hacker’s lab, tutorials, and a poster session. Attendance will be capped at 300.</p>

<p>The meeting serves as a forum for <a href="http://llvm.org">LLVM</a>,
<a href="http://clang.llvm.org">Clang</a>, <a href="http://lldb.llvm.org">LLDB</a> and
other LLVM project developers and users to get acquainted, learn how LLVM is used, and
exchange ideas about LLVM and its (potential) applications. More broadly, we
believe the event will be of particular interest to the following people:</p>

<ul>
<li>Active developers of projects in the LLVM Umbrella
(LLVM core, Clang, LLDB, libc++, compiler_rt, klee, dragonegg, lld, etc).</li>
<li>Anyone interested in using these as part of another project.</li>
<li>Compiler, programming language, and runtime enthusiasts.</li>
<li>Those interested in using compiler and toolchain technology in novel
and interesting ways.</li>
</ul>


<div class="www_sectiontitle" id="registration">Registration and Mailing Lists</div>
Registration is closed. Please contact the meeting planner, <a href="mailto:rebekka_bennett@apple.com?subject=LLVM%20Developer%20Meeting%20(ID%3A21859)">Rebekka Bennett</a>, with any questions regarding your registration.
<!--<p>Registration is currently full! Visit this <a href="https://www.seeuthere.com/rsvp/invitation/invitation.asp?id=/m1312d71-RC0Y39QYK9W2">link</a> to be added to the waiting list (popups must be enabled).</p>
-->
<!--Registration is now open until October 13th. Visit this <a href="https://www.seeuthere.com/rsvp/invitation/invitation.asp?id=/m1312d71-RC0Y39QYK9W2">site</a> to register.
--!></p>
<p>
Please sign up for the LLVM Developers' Meeting list for future announcements and to ask questions.
<br>
<a href="http://lists.cs.uiuc.edu/mailman/listinfo/llvm-devmeeting">http://lists.cs.uiuc.edu/mailman/listinfo/llvm-devmeeting</a>
</p>

<div class="www_sectiontitle" id="agenda1">October 28 - Meeting Agenda</div>
<p>
<table id="devmtg">
  <tr><th>Time</th><th>Talk</th><th>Location</th></tr>

  <tr><td>8:00 - 9:00</td><td>Breakfast</td><td>Oak Fir - Foyer</td></tr>
  <tr class="alt"><td>9:00 - 9:15</td><td><b>Welcome</b><br>Tanya Lattner, <i>LLVM Foundation</i></td><td>Oak Fir</td></tr>

  <tr><td>9:15 - 10:00</td><td><b><a href="#talk1">OpenMP Support in Clang/LLVM: Status Update and Future Directions</a></b><br>Alexey Bataev, <i>Intel</i><br>Zinovy Nis, <i>Intel</i></td><td>Oak Fir</td></tr>

<tr class="alt"><td rowspan=3>10:00 - 10:45</td><td><b><a href="#talk2">Alive: Provably Correct InstCombine Optimizations
</a></b><br>David Menendez, <i>Rutgers University</i></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#talk3">LLVM Stable Releases</a></b><br>Tom Stellard, <i>Advanced Micro Devices</i></td><td>Pine</td></tr>
  <tr class="alt"><td><a href="#bof1"><b>BOF: JIT Support in LLVM</b></a><br>Lang Hames, <i>Apple</i></td><td>Cedar</td></tr>

<tr><td rowspan=3>10:45 - 11:30</td><td><b><a href="#talk4">Supporting Precise Relocating Garbage Collection in LLVM</a></b><br>Philip Reames, <i>Azul Systems</i></td><td>Oak Fir</td></tr>
  <tr><td><b><a href="#talk5">Source Code Analysis for Security through LLVM</a></b><br>Lu Zhao, <i>HP Fortify</i></td><td>Pine</td></tr>
  <tr><td><a href="#bof2"><b>BOF: Performance tracking & benchmarking infrastructure</b></a><br>Kristof Beyls, <i>ARM</i><br>Chad Rosier, <i>QuIC</i><br>Chris Matthew, <i>Apple</i><br>Tobias Grosser, <i>ETH</i><br>Renato Golin, <i>Linaro</i></td><td>Cedar</td></tr>

<tr class="alt"><td rowspan=2>11:30 - 12:15</td><td><b><a href="#talk6">FTL: WebKit’s LLVM based JIT</a></b><br>Andrew Trick, <i>Apple</i></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#talk7">Virtual Ghost: Using LLVM to Protect Applications from a Compromised Operating System</a></b><br>John Criswell, <i>University of Rochester</i></td><td>Pine</td></tr>

  <tr><td>12:15 - 1:45</td><td>Lunch</td><td>TBD</td></tr>

<tr class="alt"><td rowspan=2>1:45 - 2:45</td><td><b><a href="#hacker">Hacker's Lab</a></b></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#tutorial1">Building an LLVM Backend</a></b><br>Fraser Cormack, <i>Codeplay Software</i><br>Pierre-André Saulais, <i>Codeplay Software</i></td><td>Pine</td></tr>


<tr><td rowspan=2>2:45 - 3:45</td>
<td><b><a href="#hacker">Hacker's Lab</a></b></td><td>Oak Fir</td></tr>
<tr><td><b><a href="#tutorial2">Adding and Optimizing a Subtarget for MIScheduler</a></b><br>Dave Estes, <i>QuIC</i></td><td>Pine</td></tr>

<tr class="alt"><td rowspan=2>3:45 - 4:45</td><td><b><a href="#hacker">Hacker's Lab</a></b></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#tutorial3">Debug Info Tutorial</a></b><br>Eric Christopher, <i>Google</i><br>David Blaikie, <i>Google</i></td><td>Pine</td></tr>
  <tr><td>4:45 - 5:30</td><td><a href="#hacker"><b>Hacker's Lab</a></b></td><td>Oak Fir</td></tr>
  <tr class="alt"><td>6:00 - 8:00</td><td>Evening Social</td><td></td></tr>
</table>
</p>

<div class="www_sectiontitle" id="agenda2">October 29 - Meeting Agenda</div>
<p>
<table id="devmtg">
  <tr><th>Time</th><th>Talk</th><th>Location</th></tr>

  <tr><td>8:00 - 9:00</td><td>Breakfast</td><td>Oak Fir Foyer</td></tr>
  <tr class="alt"><td>9:00 - 9:45</td><td><b><a href="#talk8">Swift's High-Level IR: A Case Study of Complementing LLVM IR with Language-Specific Optimization</a></b><br>Chris Lattner, <i>Apple</i><br>Joe Groff, <i>Apple</i></td><td>Oak Fir</td></tr>

<tr><td rowspan=3>9:45 - 10:30</td><td><b><a href="#talk9">What does it take to get LLVM as performant as GCC</a></b><br>James Molloy, <i>ARM</i><br>Ana Pazos, <i>QuIC</i></td><td>Oak Fir</td></tr>
<tr><td><b><a href="#talk10">Blowing up the Atomic Barrier</a></b><br>Robin Morisset, <i>Google</i></td><td>Pine</td></tr>
  <tr><td><a href="#bof3"><b>BOF: Debug Info</b></a><br>Eric Christopher, <i>Google</i></td><td>Cedar</td></tr>

<tr class="alt"><td>10:30 - 11:00</td><td>Break</td><td>Oak Fir Foyer</td></tr>

<tr><td rowspan=3>11:00 - 11:45</td><td><b><a href="#talk11">The LLVM Pass Manager, Part 2
</a></b><br>Chandler Carruth, <i>Google</i></td><td>Oak Fir</td></tr>
  <tr><td><b><a href="#talk12">Supporting Vector Programming on a Bi-Endian Processor Architecture</a></b><br>Bill Schmidt, <i>IBM</i></td><td>Pine</td></tr>
  <tr><td><a href="#bof4"><b>BOF: Improving LLVM for remote test execution</b></a><br>Brian Rzycki, <i>Samsung Austin R&D Center</i></td><td>Cedar</td></tr>

 <tr class="alt"><td rowspan=3>11:45 - 12:30</td><td><b><a href="#talk13">Intrinsics, Metadata and Attributes: Now, more than ever!
</a></b><br>Hal Finkel, <i>Argonne National Laboratory</i></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#talk14">Implementing Data Layout Optimizations in LLVM Framework</a></b><br>Prashantha NR, <i>Compiler Tree Technologies</i></td><td>Pine</td></tr>
  <tr class="alt"><td><a href="#bof5"><b>BOF: Future directions and features for LLDB</b></a><br>Deepak Mathews Panickal,<i>Codeplay Software</i></td><td>Cedar</td></tr>

<tr><td rowspan=3>12:30 - 1:15</td><td><b><a href="#talk15">Fuzzing Clang to Find ABI Bugs</a></b><br>David Majnemer, <i>Google</i></td><td>Oak Fir</td></tr>
  <tr><td><b><a href="#talk16">A closer look at ARM code quality</a></b><br>Tilmann Scheller, <i>Samsung Electronics</i></td><td>Pine</td></tr>
<tr><td><a href="#bof6"><b>BOF: GPU Implementers</b></a><br>Tom Stellard, <i>AMD</i><br>Owen Anderson, <i>Apple</i></td><td>Cedar</td></tr>
  

<tr class="alt"><td>1:15 - 2:30</td><td>Lunch</td><td>TBD</td></tr>

<tr><td rowspan=3>2:30 - 3:15</td><td><b><a href="#talk17">Implementation of global instruction scheduling in LLVM infrastructure</a></b><br>Sergei Larin, <i>QuIC</i><br>Aditya Kumar, <i>QuIC</i></td><td>Oak Fir</td></tr>
  <tr><td><b><a href="#talk18">Skip the FFI: Embedding Clang for C Interoperability</a></b><br>Jordan Rose, <i>Apple</i><br>John McCall, <i>Apple</i></td><td>Pine</td></tr>
<tr><td><a href="#bof7"><b>BOF: LLVM Inliner Improvements</a></b><br>Yin Ma, <i>QuIC</i><br>Ana Pazos, <i>QuIC</i><br>Jiangling Liu, <i>ARM</i></td><td>Cedar</td></tr>

<tr class="alt"><td rowspan=3>3:15 - 4:00</td><td><b><a href="#light">Lightning Talks</a></b></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#talk19">Custom Hardware State-Machines and Datapaths: Using LLVM to Generate FPGA Accelerators</a></b><br>Alan Baker, <i>Altera Corporation</i></td><td>Pine</td></tr>
<tr class="alt"><td><b><a href="#bof8">BOF: LTO</a></b><br>Tony Linthicum, <i>QuIC</i>, <br>Dan Palermo, <i>QuIC</i></td><td>Cedar</td></tr>

<tr><td>4:00 - 5:00</td><td><b><a href="#poster">Posters</a></b></td><td>Oak Fir Foyer</td></tr>

<tr class="alt"><td rowspan=3>5:00 - 5:45</td><td><b><a href="#talk20">Controlling Virtual Register Pressure in LLVM Middle-End</a></b><br>Ivan Baev, <i>QuIC</i></td><td>Oak Fir</td></tr>
  <tr class="alt"><td><b><a href="#talk21">Indexing Large, Mixed-Language Codebases</a></b><br>Luke Zarko, <i>Google</i></td><td>Pine</td></tr>
  <tr class="alt"><td><a href="#bof9"><b>BOF: Lld</b></a><br>Shankar Easwaran, <i>QuIC</i><br>Daniel Stewart, <i>QuIC</i></td><td>Cedar</td></tr>

<tr><td rowspan=3>5:45 - 6:30</td><td><a href="#talk22"><b>Architecture Specific Code Generation and Function Multiversioning</a></b><br>Eric Christopher, <i>Google</i></td><td>Oak Fir</td></tr>
  <tr><td><b><a href="#talk23">Frappé: Using Clang to Query and Visualize Large Codebases</a></b><br>Nathan Hawes, <i>Oracle</i><br>Ben Barham, <i>Oracle</i></td><td>Pine</td></tr>
</table>
</p>

<div class="www_sectiontitle" id="abstracts">Talk Abstracts</div>

<p>
<b><a id="talk1">OpenMP Support in Clang/LLVM: Status Update and Future Directions
</a></b><br>
<i>Alexey Bataev (Speaker) - Intel,  Zinovy Nis (Speaker) - Intel</i><br>
OpenMP is a well-known and widely used API for shared-memory parallelism. Support for OpenMP in Clang/LLVM compiler is currently under development. In this talk, we will present current status of OpenMP support, what is done and what remains to be done, technical details behind OpenMP implementation. Also, we will elaborate on accelerators and pragma-assisted SIMD vectorization, introduced in the latest 4.0 edition of the OpenMP standard.
</p>

<p>
<b><a id="talk2">Alive: Provably Correct InstCombine Optimizations
</a></b><br>
<i>Nuno Lopes - Microsoft Research, David Menendez (Speaker) - Rutgers University, Santosh Nagarakatte - Rutgers University
John Regehr - University of Utah
</i><br>
Optimizations are hard to get right. Even seemingly innocuous transformations in InstCombine can miss important corner cases. With Alive, you can specify peephole optimizations in a friendly, LLVM-like language, automatically determine their correctness, and generate the corresponding C++ code. 
</p>

<p>
<b><a id="talk3">LLVM Stable Releases
</a></b><br>
<i>Tom Stellard - Advanced Micro Devices</i><br>
This talk will cover LLVM stable releases, how they work, who uses them,
and how we can make them better.
</p>

<p>
<b><a id="talk4">Supporting Precise Relocating Garbage Collection in LLVM
</a></b><br>
<i>Philip Reames (Speaker) - Azul Systems, Sanjoy Das - Azul Systems</i><br>
Generating efficient code that is compatible with common high performance garbage collector implementations will strengthen LLVM's ability to support languages with managed runtime environments. To support this common use case, we have built and are in the process of contributing a safepoint insertion pass which can rewrite optimized IR into a form which respects the invariants required by a fully relocating garbage collector, and a set of intrinsics which enable work towards efficient lowering of safepoints.  We'll cover the motivation, high level design, and show off some examples. 
</p>

<p>
<b><a id="talk5">Source Code Analysis for Security through LLVM
</a></b><br>
<i>Lu Zhao - HP Fortify</i><br>
We added a new debug mode for the Clang compiler which emits extra metadata in the LLVM bitcode. The metadata has turned the bitcode into a useful vehicle from which an intermediate representation for secure source code analysis can be derived. We have used this approach to find security vulnerabilities in the Objective-C source code.
</p>

<p>
<b><a id="talk6">FTL: WebKit’s LLVM based JIT
</a></b><br>
<i>Andrew Trick (Speaker) - Apple, Juergen Ributzka (Speaker) - Apple</i><br>
FTL is the fourth-tier LLVM JIT that powers JavaScript in WebKit. We will talk about our experiences using LLVM to build this high-performance JIT. We will explain the motivation for new LLVM features, including patchpoints and a new form of stack maps, and will share our vision on future work and the direction we would like LLVM move to become a better platform for JIT clients.
</p>


<p>
<b><a id="talk7">Virtual Ghost: Using LLVM to Protect Applications from a Compromised Operating System
</a></b><br>
<i>John Criswell - University of Rochester</i><br>
This talk presents an LLVM-based system named Virtual Ghost that protects applications from a compromised operating system kernel.  Virtual Ghost uses compiler instrumentation to protect application data from spying and corruption from the operating system kernel.  It also uses an extended version of the LLVM instruction set to restrict how the operating system kernel can interact with the hardware, preventing the operating system kernel from using hardware configuration to corrupt application control-flow or to bypass the application data protection guarantees.
</p>

<p>
<b><a id="talk8">Swift's High-Level IR: A Case Study of Complementing LLVM IR with Language-Specific Optimization
</a></b><br>
<i>Chris Lattner (Speaker) - Apple, 
Joe Groff (Speaker) - Apple</i><br>
The Swift programming language is built on LLVM and uses LLVM IR and the LLVM backend for code generation, but it also contains a new high-level IR called SIL to model the semantics of the language (and perform optimizations) at a higher level.   In this talk, we discuss the motivations and applications of SIL, including high-level semantic analyses and transformations such as flow-dependent diagnostics, devirtualization, specialization, reference counting optimization, and TBAA, and we compare SIL's design with that of LLVM IR.
</p>

<p>
<b><a id="talk9">What does it take to make LLVM as performant as GCC
</a></b><br>
<i>James Molloy (Speaker) - ARM, 
Ana Pazos (Speaker) - QuIC, 
Yin Ma - QuIC
</i><br>
For the past 7 months Qualcomm and ARM have jointly been analyzing and improving performance for the AArch64 architecture in LLVM, based on a differential analysis against GCC. This talk aims to provide information on the areas that we're currently lacking compared to GCC, along with the progress that we've made so far.
</p>

<p>
<b><a id="talk10">Blowing up the Atomic Barrier
</a></b><br>
<i>Robin Morisset (Speaker) - Google, 
JF Bastien -  Google</i><br>
Atomics in C11 and C++11 let the programmer express the guarantees needed for racy accesses in lock-free code, in theory bringing a zero-cost abstraction for parallelism to the language. This talk will showcase how you can use atomics today and where the abstraction breaks down. We’ll focus on LLVM’s recent improvements for atomics that provide significant performance gains on ARMv7, Power and x86. Finally we’ll discuss some extremely non-intuitive behaviors of atomics, how atomics in C++ may evolve, and how it may impact LLVM.
</p>

<p>
<b><a id="talk11">The LLVM Pass Manager, Part 2
</a></b><br>
<i>Chandler Carruth - Google</i><br>
I will present a new design and implementation of the LLVM pass manager that is currently being developed in the tree. I will cover how it differs from the previous implementation and how those differences allow it to solve many of the long-standing limitations of the current implementation. I will discuss in depth how the new system supports richer analysis dependencies, flexible composition of function-level analyses and module- or call-graph-level transformations. The new pass manager also introduces a caching-based scheduling model which is substantially different from the prior ones and critical to understanding the impact of transitioning. And as I go through these topics I will introduce how to write a pass suitable for the new infrastructure and how to port an existing pass to live happily in both.
<br>
Finally, I will show a specific new call-graph analysis used by the new pass manager and discuss how these two components can be used to parallelize the entire LLVM compilation pipeline. I will mention some of the basic correctness and efficiency challenges faced when running in parallel and detail the specific challenges and constraints pursuing this path would impose on analysis and optimization passes.
</p>

<p>
<b><a id="talk12">Supporting Vector Programming on a Bi-Endian Processor Architecture
</a></b><br>
<i>Bill Schmidt (Speaker) - IBM,
Michael Gschwind - IBM</i><br>
The POWER instruction set architecture is designed to support both
big-endian and little-endian memory models.  However, many of the
instructions designed for vector support assume that vector elements in
registers appear in big endian order, that is, with the lowest-numbered
vector element in the most significant portion of the register.  This
talk will outline some of the issues faced in designing a sensible
vector programming model on a bi-endian architecture with a big-endian
bias, and how we've addressed them.  We will also discuss the current
status of implementation in the GCC and Clang/LLVM compilers.
</p>

<p>
<b><a id="talk13">Intrinsics, Metadata and Attributes: Now, more than ever!
</a></b><br>
<i>Hal Finkel - Argonne National Laboratory</i><br>
Over the past year, LLVM has grown several new ways to communicate important information to the optimizer: An @llvm.assume intrinsic function to provided additional truths, scoped-noalias metadata to provided explicit pointer aliasing sets, and parameter attributes that specify pointer alignment, dereferenceability, and more. I'll explain the semantics of many of these new features, their intended uses, and a few ways they shouldn't be used. Finally, I'll discuss how Clang exposes and leverages these new features to encourage the generation of higher-performance code.
</p>

<p>
<b><a id="talk14">Implementing Data Layout Optimizations in LLVM Framework
</a></b><br>
<i>Prashantha NR (Speaker) - Compiler Tree Technologies, Vikram TV - Compiler Tree Technologies,
		   Vaivaswatha N - Compiler Tree Technologies</i><br>
Modern server workloads are limited by memory bandwidth. For regular accesses like loops, people change the loop iterations to change the access pattern; thereby gaining locality. Another way to alleviate the memory bottleneck is to change the data layout organization for better locality. In this talk we will speak about memory layout optimizations like Structure Splitting, Instance Interleaving, Struct Array copy, Array Remapping in LLVM compiler framework.
</p>

<p>
<b><a id="talk15">Fuzzing Clang to Find ABI Bugs
</a></b><br>
<i>David Majnemer - Google</i><br>
Correctly implementing C++ is very hard, bugs can arise from incredibly subtle interactions of different language features.
In this talk, we will discuss how we used fuzzing to dramatically increase the reliability of Clang's ABI-specific code.
</p>


<p>
<b><a id="talk16">A closer look at ARM code quality
</a></b><br>
<i>Tilmann Scheller - Samsung Electronics</i><br>
This talk presents current performance numbers for the SPEC CPU benchmark
suites on ARM, comparing the performance of LLVM and GCC, with the main
focus on the SPEC CPU integer benchmarks.
To dive a little bit deeper, we will also have a closer look at the
generated assembly code of selected benchmarks where LLVM is performing
worse than GCC.
We will use the results of this performance analysis to point out potential
code generation opportunities for LLVM.
</p>


<p>
<b><a id="talk17">Implementation of global instruction scheduling in LLVM infrastructure
</a></b><br>
<i>Sergei Larin (Speaker) - QuIC,  Aditya Kumar (Speaker) - QuIC</i><br>
Discuss perspectives and tradeoffs in implementation of global instruction scheduling and support for it in the LLVM infrastructure. Present and discuss relative QuIC experience.
</p>

<p>
<b><a id="talk18">Skip the FFI: Embedding Clang for C Interoperability
</a></b><br>
<i>Jordan Rose (Speaker) - Apple,
John McCall (Speaker) - Apple</i><br>
Most languages that aren't a superset of C provide a Foreign Function Interface (FFI) that allows one to interface with existing C libraries. FFIs are often an afterthought, requiring manual or source-to-source translation from C header files to a subset of the target language, resulting in complicated build processes, frequent manual tweaking, and numerous implementation challenges. 
<br>
This talk will discuss an alternative approach that embeds Clang into an LLVM-based compiler front end to provide C compatibility without the traditional FFI. Embedding Clang provides seamless access to C APIs, moving the translation of APIs from external tools into the compiler itself. Moreover, one can leverage Clang's deep knowledge of C record layout and calling conventions to simplify the C interface and make both bring up and porting of a new compiler front end simpler.
</p>

<p>
<b><a id="talk19">Custom Hardware State-Machines and Datapaths: Using LLVM to Generate FPGA Accelerators
</a></b><br>
<i>Alan Baker - Altera Corporation</i><br>
Altera Corporation’s OpenCL compiler uses LLVM to generate FPGA accelerators. In order to generate efficient hardware, many transformations were implemented. The key transformations will be discussed, emphasizing the FPGA vs CPU architectural differences that motivate them.
</p>

<p>
<b><a id="talk20">Controlling Virtual Register Pressure in LLVM Middle-End
</a></b><br>
<i>Ivan Baev - QuIC</i><br>
Enabling new compiler optimizations or compiling at higher optimization levels do not necessarily improve performance. One common reason is the increased register pressure that results in an increased amount of spill code. We analyze several LLVM target-independent optimizations with respect to register pressure. We then describe algorithms for controlling register pressure in LICM and GVN and report their positive impact on run-time performance. A discussion on how to control register pressure in the inliner concludes the talk.
</p>

<p>
<b><a id="talk21">Indexing Large, Mixed-Language Codebases
</a></b><br>
<i>James Dennett - Google,
Luke Zarko (Speaker) - Google</i><br>
The Kythe project aims to establish open data formats and protocols for
interoperable developer tools. In this talk, we will introduce the Kythe
model as it applies to C++14, concentrating on features required for generating
cross-references. In the process, we will discuss how the Clang front-end
was instrumental in developing an indexing tool that produces Kythe data
describing C++ source code.
</p>

<p>
<b><a id="talk22">Architecture Specific Code Generation and Function Multiversioning
</a></b><br>
<i>Eric Christopher - Google</i><br>
A talk on microarchitecture dependent optimization and code generation
for individual functions, the changes that have been necessary to
enable it, and function multiversioning as the next step.
</p>

<p>
<b><a id="talk23">Frappé: Using Clang to Query and Visualize Large Codebases
</a></b><br>
<i>Nathan Hawes (Speaker) - Oracle, 
Ben Barham (Speaker) - Oracle</i><br>
Frappé is a new tool to support developers with a range of code comprehension queries in multi-million line codebases, from "Does function X or something it calls write to global variable Y?" to "How much code could be affected if I change this macro?".  Results are overlaid on a visualisation of the code based on a cartographic map, where the continent/country/state hierarchy corresponds to the code equivalent: high-level architectural components down to individual files and functions. This allows users to visually filter results based on their location and more immediately guage their number and locality.
</p>

<div class="www_sectiontitle" id="light">Lightning Talk Abstracts</div>

<p>
<b>Automatic Loop Diagonalization with LLVM
</a></b><br>
<i>Vedant Kumar - UC Berkeley</i><br>
The effects of some loops can be captured by matrices. This talk shows how to take advantage of this fact to optimize away entire loops.
</p>

<p>
<b>PBQP register allocation
</a></b><br>
<i>Arnaud de Grandmaison - ARM,
 Lang Hames - Apple</i><br>
The PBQP register allocator has been part of the LLVM source code for a long time. This talk will present a high level overview of the PBQP allocator principles, as well as its status and future work.
</p>

<p>
<b>PBQP register allocation in the wild
</a></b><br>
<i>Arnaud de Grandmaison - ARM,
 Lang Hames - Apple</i><br>
This talk will present how the PBQP is used with 2 real world processors and report some performance numbers.
</p>

<p>
<b>GPolly: An Improved GPGPU Code Generation Backend for Polly
</a></b><br>
<i>Yabin Hu - 
China University of Geosciences</i><br>
GPolly is an improved GPGPU code generation backend for LLVM/Polly, which can transform sequential LLVM IRs and map them onto GPGPU architecture.
</p>

<p>
<b>Link-Time Optimization on PlayStation(R)4
</a></b><br>
<i>Yunzhong Gao - Sony Computer Entertainment America</i><br>
As a follow-up to last year's presentation, this is a talk on our experience implementing LTO on
PlayStation(R)4’s proprietary linker, including some of the challenges and results we see in the games.
</p>

<p>
<b>Software Visualizer (SWViz): A tool for visually exploring Linux kernel
with Clang
</a></b><br>
<i>Harsh Vardhan Dwivedi - QuIC</i><br>
What is SWviz and why should I care about it anyway?
SWViz is a tool to explore the call graph of a program. It’s chief advantage being able to leverage the linker and compiler (Clang) to generate accurate call-graphs. Through use of Swviz one can quickly gain an understanding of how a program is working. This leads to a massive cutdown in number of hours spent understanding the call-flow of any mature codebase. We’ll demonstrate use of SWViz with Linux Kernel.
</p>

<p>
<b>LLVM for Interactive Modeling and High Performance Simulation
</a></b><br>
<i>Peng Cheng - The MathWorks, Inc.</i><br>
At MathWorks, LLVM has been used to create multi-thread JIT engines for
interactive modeling and high performance simulation.  This talk will present
why and how LLVM is used to implement the JIT engines as well as some
challenges.
</p>

<p>
<b>AddressSanitizer for Windows
</a></b><br>
<i>Timur Iskhodzhanov - Google</i><br>
A fast memory error detector, now available to try on Windows.
Brief overview of the internals and some initial deployment results.
</p>

<div class="www_sectiontitle" id="tutorials">Tutorial Abstracts</div>

<p>
<b><a id="tutorial1">Building an LLVM Backend
</a></b><br>
<i>Fraser Cormack (Speaker) - Codeplay Software, Pierre-André Saulais (Speaker) - Codeplay Software</i><br>
This talk explains how to get started with building a LLVM backend for a new architecture. It shows how LLVM transforms programs through the back-end compilation pipeline and what needs implementing for a new target. Practical debugging tips, as well as solutions to common issues are given. No LLVM backend experience is needed, but experience with LLVM IR is recommended.
</p>

<p>
<b><a id="tutorial2">Adding and Optimizing a Subtarget for MIScheduler
</a></b><br>
<i>Dave Estes (Tutorial) - QuIC</i><br>
Tutorial for adding a subtarget to an existing backend for use with the MIScheduler. Will cover TableGen basics insofar as understanding the records used for the MachineSchedModel. Will provide strategies on how to best model some basic machine architectures.
</p>

<p>
<b><a id="tutorial3">Debug Info Tutorial
</a></b><br>
<i>Eric Christopher (Speaker) - Google,
David Blaikie (Speaker) - Google</i><br>
Take a walk through the DWARF debug information format and the llvm
APIs that serve as an interface to emitting debug information for your
language.
</p>

<div class="www_sectiontitle" id="bof">BoF Abstracts</div>

<p>
<b><a id="bof1">JIT Support in LLVM
</a></b><br>
<i>Lang Hames - Apple</i><br>
A forum for clients and developers of LLVM's JIT infrastructure to discuss APIs, features, and intrinsic support (the stackmap and patchpoint intrinsics).
</p>

<p>
<b><a id="bof2">Performance tracking & benchmarking infrastructure
</a></b><br>
<i>Kristof Beyls - ARM, Chad Rosier - QuIC, Chris Matthew - Apple, Tobias Grosser - ETH, Renato Golin - Linaro
</i><br>
Having at least some public performance tracking that the majority of the community cares about would make it easier to collaborate for all developers improving the quality of LLVM-generated code. During last year’s BoF, we identified some key shortcomings in LNT to be able to produce low-noise performance numbers on the test-suite and most of them have been fixed recently. In this BoF, we wish to mainly talk about what is needed and missing for the produced compile and execution time numbers to be quickly and easily interpreted and acted upon.
</p>

<p>
<b><a id="bof3">Debug Info BOF
</a></b><br>
<i>Eric Christopher, Google</i><br>
There's been quite a bit of interest in a Debug Info BOF following the one we had last year at the 2013 Developer Conference. This BOF will cover everything from scaling our current handling of debug information, to ongoing work on debug information correctness, and future proposals for DWARF standardization.
</p>

<p>
<b><a id="bof4">Improving LLVM for remote test execution
</a></b><br>
<i>Brian Rzycki - Samsung Austin R&D Center</i><br>
Today's LLVM testing frameworks focus on testing native compilers on the same host where the test is compiled. The goal of this BoF is to examine the components necessary for change and to discuss potential solutions that allow for running tests on remote hosts in a way that best benefits the overall community.
</p>

<p>
<b><a id="bof5">Future directions and features for LLDB
</a></b><br>
<i>Deepak Mathews Panickal - Codeplay Software</i><br>
I propose to organize a BoF to discuss mainly the following topics:
<ul>
<li> As a variety of new targets are being added that form parts of widely used heterogeneous devices, LLDB should develop a system to allow for Simultaneous Multiple Target Debugging. This would allow for the definition of behaviours for how heterogeneous systems are debugged in a single instance.
</li>
<li>Future advances of LLDB tools such as the MI interface and lldb-gdbserver, NativeProcess, NativeThread etc.
</li></ul>
</p>

<p>
<b><a id="bof6">GPU Implementers BoF
</a></b><br>
<i>Tom Stellard - AMD,
Owen Anderson - Apple</i><br>
LLVM is rapidly gaining popularity as a compilation framework for graphics processors.  This Birds of a Feather session will focus on issues of interest to implementers of GPU targets in LLVM.  Topics of discussion may include:
<ul>
<li>Techniques for overcoming common challenges in adapting LLVM to GPU targets</li>
<li>Future directions in LLVM to benefit GPU targets</li>
<li>Opportunities for different GPU targets to share infrastructure and/or optimizations</li>
</ul>
Audience participation is encouraged.  Bring your own questions and ideas!
</p>

<p>
<b><a id="bof7">LLVM Inliner Improvements
</a></b><br>
<i>Yin Ma - QuIC,
Ana Pazos - QuIC,
Jiangling Liu - ARM</i><br>
Discuss the opportunities to extend the LLVM inliner and our work greedy inliner.
</p>

<p>
<b><a id="bof8">LTO
</a></b><br>
<i>Tony Linthicum - QuIC,
Dan Palermo - QuIC</i><br>
Discuss LTO’s current state and potential future improvements.  Potential topics include, but are not limited to, the following:   passing command line arguments to LTO,  profile driven LTO optimizations,  compile time improvements and  performance improvements.
</p>


<p>
<b><a id="bof9">Lld
</a></b><br>
<i>Shankar Easwaran - QuIC,
Daniel Stewart - QuIC</i><br>
The lld linker is a solid foundation for a general-purpose linker, as well as a set of libraries for creating linker-like tools. We will talk about the current status of lld, what the shortcomings are for a production linker, and what major areas need to be implemented, such as LTO support, diagnostics, extensibility. We will also discuss the feasibility of targeting an initial set of features so that lld can be made the default linker for linking the LLVM tools
</p>

<div class="www_sectiontitle" id="poster">Poster Abstracts</div>

<p>
<b>LLVM for Interactive Modeling and High Performance Simulation
</b><br>
<i>Peng Cheng, Nathan Brewton, Dale Martin - The MathWorks, Inc.</i><br>
To enable inter-module optimization during interactive modeling for high
performance simulation of Simulink models, LLVM based JIT compilers have been
developed at MathWorks.  These JIT compilers support multiple threads on major
platforms, including win32, win64, glnax64, and maci64, and achieve superior
running time performance compared with previous shared library based compilers.
This talk will present why and how LLVM is used to implement the JIT compilers
as well as some challenges.
</p>

<p>
<b>ISPC: clang-based front-end
</b><br>
<i>Dmitry Babokin - Intel Corporation
James Brodman - Intel Corporation</i><br>
ISPC is a C-based language based on the SPMD (single program, multiple data) programming model that generates efficient SIMD code for modern processors without the need for complex analysis and autovectorization. The project uses the LLVM infrastructure for optimization and code generation but originally used a custom front-end. The poster describes our experience with building a clang-based front-end and the engineering problems we have encountered introducing the concept of “varying” types to clang.
</p>

<p>
<b>A C++ ABI Test Suite
</b><br>
<i>Sunil Srivastava - Sony Computer Entertainment</i><br>
This poster describes the design of an Itanium C++ ABI Test Suite that verifies a compiler’s compliance against the ABI specification to ensure link compatibility.
</p>

<p>
<b>Software Visualizer (SWViz): A tool for visually exploring Linux kernel
with Clang
</b><br>
<i>Harsh Vardhan Dwivedi - QuIC</i><br>
What is SWviz and why should I care about it anyway?
SWViz is a tool to explore the call graph of a program. It’s chief advantage being able to leverage the linker and compiler (Clang) to generate accurate call-graphs. Through use of Swviz one can quickly gain an understanding of how a program is working. This leads to a massive cutdown in number of hours spent understanding the call-flow of any mature codebase. We’ll demonstrate use of SWViz with Linux Kernel.
</p>

<p>
<b>Machine Guided Compilation and Compiling to Minimize Energy Usage
</b><br>
<i>Simon Cook - Embecosm, Ed Jones - Embecosm</i><br>
Today we need compilers to optimize for energy rather than just size or speed. In this poster we present the results of integrating machine learning with LLVM, so the compiler can be trained on which optimizations minimize energy. As a side effect of energy optimization we also see significant performance benefits - nearly doubling performance compared to -O3 in some cases.
</p>

<p>
<b>Translating Java into LLVM IR to Detect Security Vulnerabilities
</b><br>
<i>Cristina Cifuentes - Oracle Labs Australia, Oracle, Nathan Keynes - Parfait, Oracle, John Gough - Oracle Labs Australia, Oracle, Diane Corney - Oracle Labs Australia, Oracle, Lin Gao - Parfait, Oracle, Manuel Valdiviezo - Parfait, Oracle, Andrew Gross - Java Security, Oracle
</i><br>
This poster describes one of several new Java security vulnerabilities and how we reused and extended LLVM’s IR in order to detect such vulnerability.  One year later, full support for Java 7 and 8 are in place, along with various analyses that detect Java platform vulnerabilities.
</p>

<p>
<b>Intel® AVX-512 architecture evolution and support in Clang/LLVM
</b><br>
<i>Zinovy Nis - Intel Corporation, Robert Khasanov - Intel Corporation</i><br>
Intel® AVX-512 vector ISA continues to evolve. It has recently been enriched with new groups of instructions operating on different vector lengths and different vector element sizes. We’ll present the current status of new AVX-512 features enabling in CLANG/LLVM  and show how these features can be exploited for performance improvements particularly by vectorizer.
</p>

<p>
<b>mcsema
</b><br>
<i>Artem Dinaburg - Trail of Bits, Inc.
Andrew Ruef - Trail of Bits, Inc.
Jay Little - Trail of Bits, Inc.</i><br>
mcsema is a framework for analyzing and transforming machine-code programs to LLVM bitcode. It supports translation of x86 machine code, including integer, floating point, and SSE instructions.
</p>

<p>
<b>Carte++: A LLVM-Based Compiler Targeting FPGAs
</b><br>
<i>Jeffrey Hammes, Lisa Krause , Matthew O’Connor, Jon Steidel - SRC Computers, LLC
</i><br>
SRC Computers, LLC is presenting a poster on its upcoming Carte++ compiler release showing how the Clang/LLVM infrastructure has provided full language support and a rich set of compiler optimizations upon which to build the Carte++ code generator. The poster will illustrate specific optimizations and compiler challenges unique to SRC's FPGA-based hardware.
</p>

<div class="www_sectiontitle" id="logistics">Logistics</div>
<p>
<a href="http://doubletree3.hilton.com/en/hotels/california/doubletree-by-hilton-hotel-san-jose-JOSE-DT/index.html">DoubleTree by Hilton San Jose</a>
<br>2050 Gateway Place
<br>San Jose, CA 95110
</p><p>
You may book their hotel stay by using this <a href="https://resweb.passkey.com/go/LLVM2014">link</a>.</p>
<p>Rate: $209 plus local taxes for superior double queen or superior king rooms
</p>
<p>Self Parking is $19 per day.</p>
<!-- *********************************************************************** -->
<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"></a>
<br>
</address>

<!--#include virtual="../../footer.incl" -->

